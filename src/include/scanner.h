/**
 * @file scanner.h
 * 
 * @brief functions and structures used in scanner
 * @author Krištof Šiška - xsiska16
 *         Šimon Šmída   - xsmida03
 */

#ifndef LEX_AN_H
#define LEX_AN_H

#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <string.h>
#include "buffer.h"


#define DEFAULT_STATE 200
#define START_COMMENT_OR_MINUS 201 // Used when previous state was default and a '-' char was found
#define ON_COMMENT 202 // Found "--" in text
#define CHECK_COMMENT_BLOCK 203 // Used when we are on ON_COMMENT state and we check for '[' char
#define INSIDE_LINE_COMMENT 204 // Found "--" in text but not a "--[[" Identifying block comment
#define INSIDE_BLOCK_COMMENT 205 // Found "--[[" in source code and we are ignoring all chars until we find "]]"
#define CHECK_END_BLOCK_COMMENT 206 // Found a ']' in block comment
#define ID_OR_KEYWORD 207 // 
#define STRING_LITERAL 208 // Found '"' in text signalizing string literal
#define OPERATOR 209 //
#define NUMBER_SEQUENCE 210 // Found a number
#define DOUBLE_DOT_SEQUENCE 211
#define DOUBLE_DOT_SEQUENCE_VALID 212 // Found a digit after '.' 
#define DOUBLE_E_SEQUENCE 213
#define DOUBLE_E_SEQUENCE_VALID 214 // Found a digit adfter 'e' or 'E'
#define DOUBLE_E_PLUS_MINUS_SEQUENCE 215
#define DOUBLE_E_PLUS_MINUS_SEQUENCE_VALID 216 // Found digit after 'e' or 'E' concat '+' or '-'
#define ESCAPE_SEQUENCE 217
#define ESCAPE_1 218
#define ESCAPE_2 219
#define ASSIGN_OR_EQUALS 220
#define L_PAREN 221
#define R_PAREN 222

#define COLON 223
#define SEPARATOR 224

#define STATE_EOF 225
#define STATE_ERROR 226


#define SIZE_STRING 5

#define NUM_OF_KEYWORDS 12
#define NUM_OF_VAR_TYPE 5
#define NUM_OF_OPERATORS 9



typedef enum token_types {
    // Special
    TOKEN_ERROR,
    TOKEN_EOF,
	TOKEN_IFJ21, // TODO: prob. redundant

    // Separators
    TOKEN_L_PAR,
    TOKEN_R_PAR,
    TOKEN_COMMA,
    TOKEN_COLON,

    // Arithmetic operators
    TOKEN_PLUS,
    TOKEN_MINUS,
    TOKEN_MUL,
    TOKEN_DIV,

    // Relational operators
    TOKEN_EQ,     // ==
    TOKEN_NOT_EQ, // ~=
    TOKEN_LT,     // <
    TOKEN_LE,     // <=
    TOKEN_GT,     // >
    TOKEN_GE,     // >=
    TOKEN_INT_DIV, // //

    
    // Other operators
    TOKEN_STRLEN, // # string length
    TOKEN_CONCAT, // .. concatenates two strings

    // Assignment
    TOKEN_ASSIGN,

    // Identifier
    TOKEN_ID,

    // Keyword
    TOKEN_KEYWORD,

    TOKEN_STR_LIT,
    TOKEN_INT_LIT,
    TOKEN_NUM_LIT,

} token_type_t;

typedef enum keyword_type {
    KEYWORD_REQUIRE,
    KEYWORD_DO,
    KEYWORD_IF,
    KEYWORD_ELSE,
    KEYWORD_END,
    KEYWORD_FUNCTION,
    KEYWORD_GLOBAL,
    KEYWORD_LOCAL,
    KEYWORD_NIL,    // data type
    KEYWORD_STRING, // data type
    KEYWORD_INTEGER,// data type
    KEYWORD_NUMBER, // data type
    KEYWORD_DOUBLE,
    KEYWORD_RETURN,
    KEYWORD_THEN,
    KEYWORD_WHILE,
} keyword_type_t;

typedef struct attribute {
    char *string;
    int integer;
    double number;
    keyword_type_t keyword_type;
} token_attribute_t;

typedef struct token {
    token_type_t type;
    token_attribute_t *attribute;
} token_t;


/**
 * @brief Scans the input file - the main function of the scanner
 *
 * @param file input file
 * @return token generated by generate_token() function if successful,
 *         otherwise NULL
 */
token_t *get_next_token(FILE *file);

/**
 * @brief Generates new token from given string buffer and token's type
 *
 * @param buffer pointer to a dynamic string buffer
 * @param type type of the token
 * @return token structure
 */
token_t *generate_token(string_t *buffer, int type, int error);

/**
 * @brief Determines whether a given character is operator
 * 
 * @param int c
 * @return true if character is operator, otherwise false
 */
bool is_operator(int c);

/** 
 * @brief Determines whether a given string is a variable type
 * aka "integer" or "double" etc
 * 
 * @param string A buffer to check
 * @return True if string is a variable_type, otherwise false 
 */
bool is_variable_type(char *string);

/**
 * @brief Determines whether a given string is a keyword
 * 
 * @param string A buffer to check
 * @return True if string is a keyword, otherwise false
 */
bool is_keyword(char *string);

/**
 * @brief Converts given integer type of a token to its string version
 *
 * @param type token type
 * @return pointer to the string version of a token type
 */
const char *token_type_to_str(int type);


// TODO: add line number?
/**
 * @brief Auxiliary function that prints string representation of current token
 * @param token token to be printed
 */
void print_token(token_t *token);

/**
 * @brief Function to determine which keyword is in string
 * 
 * @param string 
 */ 
keyword_type_t determine_keyword(const char *string);
#endif // LEX_AN_H
